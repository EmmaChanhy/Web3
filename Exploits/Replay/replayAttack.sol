// Replay Attack Definition:
// A replay attack occurs when a malicious user exploits the reuse of another user's transaction signature
// to execute the same action. In this scenario, the transaction signature lacks uniqueness,
// enabling unauthorized users to replicate and potentially manipulate transactions originally intended for a specific user.

// Source: https://solidity-by-example.org/signature/
// Real case: https://medium.com/immunefi/hack-analysis-nomad-bridge-august-2022-5aa63d53814a

// Exploit
function verifyNotSecureSignature (
    address to,
    uint256 amount,
    bytes memory signature
) public pure returns (address signer) {
    // Ethereum Signed Message standard header
    string memory header = "\x19Ethereum Signed Message:\n32";

    // Calculate the hash of the message
    bytes32 messageHash = keccak256(abi.encodePacked(header, to, amount));

    // Split the signature into r, s, and v components
    (uint8 v, bytes32 r, bytes32 s) = ethers.utils.splitSignature(signature);

    // Recover the Ethereum address from the signature
    signer = ecrecover(messageHash, v, r, s);

    // Return the recovered address
    return signer;
}

verifyNotSecureSignature(
    attacker.address, 
    ethers.utils.parseEther("1"), 
    signature
    );

// Secure solution with nonce
function verifySecureSignature (
    address to,
    uint256 amount,
    bytes memory signature,
    uint nonce,
) public pure returns (address signer) {

    string memory header = "\x19Ethereum Signed Message:\n32";

    bytes32 messageHash = keccak256(abi.encodePacked(header, to, amount, nonce));

    (uint8 v, bytes32 r, bytes32 s) = ethers.utils.splitSignature(signature);

    signer = ecrecover(messageHash, v, r, s);

    return signer;
}

// Solutions
// Add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 permit()
// Link: https://eips.ethereum.org/EIPS/eip-2612
// Link: https://medium.com/@afterdark_labs/eips-explained-eip-2612-9c7d6690802d
// Link: https://medium.com/frak-defi/erc-2612-the-ultimate-guide-to-gasless-erc-20-approvals-2cd32ddee534

// Generate random signature
struct Signature {
    uint8 v;
    bytes32 r;
    bytes32 s;
}

Signature memory signature = (1, keccak256("random"), keccak256("random"));